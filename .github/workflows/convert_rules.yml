name: Auto Convert Clash Rules to MRS

on:
  push:
    branches:
      - main
  workflow_dispatch: # 允许手动触发
  schedule:
    - cron: '0 0 * * 0' # 每周日 UTC 时间 00:00 运行

jobs:
  convert-rules:
    runs-on: ubuntu-latest
    permissions:
      contents: write # 授予 action 修改仓库内容的权限

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all tags, so we can count previous runs on the same day.

      - name: Install dependencies (jq, curl, wget)
        run: sudo apt-get update && sudo apt-get install -y jq curl wget

      - name: Install Mihomo
        run: |
          # 增加版本选择的健壮性，优先选择 compatible 版本
          MIHOMO_LATEST_URL=$(curl -s "https://api.github.com/repos/MetaCubeX/mihomo/releases/latest" | jq -r '.assets[] | select(.name | contains("linux-amd64-compatible")) | .browser_download_url')
          
          # 如果没有 compatible 版本，则选择一个通用的版本作为备用
          if [ -z "$MIHOMO_LATEST_URL" ]; then
            MIHOMO_LATEST_URL=$(curl -s "https://api.github.com/repos/MetaCubeX/mihomo/releases/latest" | jq -r '[.assets[] | select(.name | contains("linux-amd64") and endswith(".gz"))] | .[0].browser_download_url')
          fi

          echo "Downloading Mihomo from $MIHOMO_LATEST_URL"
          
          # 下载、解压、赋予执行权限并移动到系统路径
          wget -qO mihomo.gz "$MIHOMO_LATEST_URL"
          gunzip mihomo.gz
          chmod +x mihomo
          sudo mv mihomo /usr/local/bin/
          
          # 验证安装成功
          echo "Mihomo version:"
          mihomo -v

      - name: Process and Convert Rules
        id: process_rules
        run: |
          set -e # 如果任何命令失败，则立即退出

          # --- 全局变量和初始化 ---
          # 创建临时目录
          DOWNLOADS_DIR="downloads_tmp"
          mkdir -p "$DOWNLOADS_DIR"

          # 创建版本化输出目录
          DATE_SUFFIX=$(date -u +"%Y-%m-%d")
          RUN_COUNT=$(git tag -l "${DATE_SUFFIX}-*" | wc -l)
          VERSION_TAG="${DATE_SUFFIX}-${RUN_COUNT}"
          VERSIONED_OUTPUT_DIR="versioned_rules/$VERSION_TAG"
          RULES_OUTPUT_DIR="$VERSIONED_OUTPUT_DIR/rules"
          mkdir -p "$RULES_OUTPUT_DIR"
          
          # 临时文件，用于存储最终配置文件的各个部分
          PROVIDER_LINES_TMP="provider_lines.tmp"
          RULESET_LINES_TMP="ruleset_lines.tmp"
          > "$PROVIDER_LINES_TMP"
          > "$RULESET_LINES_TMP"

          # --- 函数定义 ---

          # 函数：转换规则并记录结果
          convert_and_commit_rule() {
              local type="$1"              # domain, ipcidr, classical
              local format="$2"            # yaml, text
              local input_file="$3"        # 带有原始格式的输入文件
              local base_name="$4"         # 文件基础名 (e.g., Inside_domain)
              local output_dir="$5"        # 输出目录 (e.g., versioned_rules/2025-09-23/rules)
              local original_name_with_emoji="$6" # 源文件中的原始名称 (e.g., 🎯 国内流量)

              local provider_name="$base_name"
              local final_raw_file="$output_dir/${base_name}.txt"
              local url_path="main/latest/${base_name}"

              if [[ "$type" == "classical" ]]; then
                  local output_file="$output_dir/${base_name}.list"
                  url_path+=".list"
                  cp "$input_file" "$output_file" #直接复制
                  echo "  Archived unsupported rules to ${output_file}"
              else
                  local output_file="$output_dir/${base_name}.mrs"
                  url_path+=".mrs"
                  local temp_clean_input="cleaned_for_mrs.tmp"

                  # 预处理：移除类型前缀，为mrs转换做准备
                  # e.g., from "DOMAIN-SUFFIX,google.com" to "google.com"
                  awk -F, '{print $2}' "$input_file" > "$temp_clean_input"

                  echo "  Converting: Type=${type}, Format=${format}"
                  if mihomo convert-ruleset "$type" "$format" "$temp_clean_input" "$output_file"; then
                      echo "  Successfully converted to ${output_file}"
                  else
                      echo "  Error: Conversion for ${input_file} failed."
                      rm -f "$temp_clean_input"
                      return 1
                  fi
                  rm -f "$temp_clean_input"
              fi

              if [ -s "$output_file" ]; then
                  # 归档带有原始格式的源文件
                  cp "$input_file" "$final_raw_file"

                  # 生成 provider 配置行
                  local anchor_name="$type"
                  local full_url="https://raw.githubusercontent.com/${{ github.repository }}/${url_path}"
                  echo "  ${provider_name}: { <<: *${anchor_name}, url: '${full_url}' }" >> "$PROVIDER_LINES_TMP"
                  
                  # 生成 rule-set 配置行
                  echo "- RULE-SET,${provider_name},${original_name_with_emoji}" >> "$RULESET_LINES_TMP"
              fi
          }

          # 函数：拆分 .list/.txt 并进行转换
          split_and_convert() {
              local input_file="$1"
              local base_name="$2"
              local output_dir="$3"
              local original_name_with_emoji="$4"

              echo "  File is a .txt/.list, attempting to split into domain/ipcidr/other..."
              
              local domain_file="${base_name}_domain.txt"
              local ipcidr_file="${base_name}_ipcidr.txt"
              local other_file="${base_name}_other.list"
              > "$domain_file"
              > "$ipcidr_file"
              > "$other_file"
              
              # 使用 awk 高效拆分文件，并保持原始格式
              awk -F, '
                  function strip(s) {
                      sub(/^[ \t\r\n]+/, "", s);
                      sub(/[ \t\r\n]+$/, "", s);
                      return s;
                  }
                  !/^#/ && !/^[ \t\r\n]*$/ {
                      line = strip($0);
                      type = toupper(strip($1));
                      if (type == "DOMAIN" || type == "DOMAIN-SUFFIX" || type == "DOMAIN-KEYWORD") {
                          print line >> "'"$domain_file"'"
                      } else if (type == "IP-CIDR") {
                          print line >> "'"$ipcidr_file"'"
                      } else {
                          print line >> "'"$other_file"'"
                      }
                  }
              ' "$input_file"

              # 转换拆分后的文件
              if [ -s "$domain_file" ]; then
                  convert_and_commit_rule "domain" "text" "$domain_file" "${base_name}_domain" "$output_dir" "${original_name_with_emoji} (Domain)"
              fi
              if [ -s "$ipcidr_file" ]; then
                  convert_and_commit_rule "ipcidr" "text" "$ipcidr_file" "${base_name}_ipcidr" "$output_dir" "${original_name_with_emoji} (IP)"
              fi
              if [ -s "$other_file" ]; then
                  convert_and_commit_rule "classical" "text" "$other_file" "${base_name}_other" "$output_dir" "${original_name_with_emoji} (Unsupported)"
              fi
              
              rm -f "$domain_file" "$ipcidr_file" "$other_file"
          }

          # 函数：处理单个规则
          process_rule() {
              local original_name="$1"
              local url="$2"
              
              echo "---"
              echo "Processing: Name='${original_name}', URL='${url}'"

              # 检查 URL 是否有效
              if ! [[ "$url" =~ ^https?:// ]]; then
                  echo "  Warning: Invalid URL format, skipping."
                  return
              fi

              local sanitized_filename_base=$(basename "$url" | sed 's/\.[^.]*$//' | sed 's/[^a-zA-Z0-9_.-]//g')
              local extension="${url##*.}"
              local downloaded_file="$DOWNLOADS_DIR/${sanitized_filename_base}.${extension}"

              echo "  Downloading to ${downloaded_file}..."
              if ! curl -L --retry 3 --fail -s -o "$downloaded_file" "$url"; then
                  echo "  Warning: Download failed for ${url} after 3 retries, skipping."
                  return
              fi

              if [[ "$extension" == "yaml" ]]; then
                  # 假设 yaml 文件是纯 domain 类型
                  convert_and_commit_rule "domain" "yaml" "$downloaded_file" "$sanitized_filename_base" "$RULES_OUTPUT_DIR" "$original_name"
              elif [[ "$extension" == "txt" || "$extension" == "list" ]]; then
                  split_and_convert "$downloaded_file" "$sanitized_filename_base" "$RULES_OUTPUT_DIR" "$original_name"
              else
                  echo "  Warning: Unsupported file extension '.${extension}', skipping."
              fi
          }

          # --- 主逻辑 ---
          if [ -s "rule_sources.txt" ]; then
              echo "Custom 'rule_sources.txt' found, processing it."
              while IFS= read -r url; do
                  url=$(echo "$url" | xargs) # 清理空格和换行符
                  if [ -n "$url" ]; then
                      # 从 URL 中提取一个合适的名字
                      local name=$(basename "$url" | sed 's/\.[^.]*$//')
                      process_rule "$name" "$url"
                  fi
              done < rule_sources.txt
          else
              echo "'rule_sources.txt' not found or is empty, using default .ini file."
              INI_URL="https://raw.githubusercontent.com/cutethotw/ClashRule/main/GeneralClashRule.ini"
              INI_FILE="$DOWNLOADS_DIR/GeneralClashRule.ini"
              curl -s -o "$INI_FILE" "$INI_URL"

              # 解析 .ini 文件, `|| true` 防止在没有匹配项时脚本因 grep 的退出码 1 而失败
              grep -E '^\s*ruleset=' "$INI_FILE" || true | while IFS= read -r line; do
                  # 移除行首的 'ruleset=' 和可能的 'clash-classic:'
                  line_content=$(echo "$line" | sed -e 's/^\s*ruleset=//' -e 's/clash-classic://')
                  
                  # 更健壮的提取逻辑
                  # URL 是最后一个逗号之后的所有内容
                  url=$(echo "$line_content" | sed -e 's/.*,//' -e 's/^[ \t]*//' -e 's/[ \t]*$//')
                  # 名称是第一个逗号之前的所有内容
                  original_name=$(echo "$line_content" | sed -e 's/,.*//' -e 's/^[ \t]*//' -e 's/[ \t]*$//')

                  # 增加一个检查，防止从格式错误的行中提取出空URL
                  if [ -z "$url" ]; then
                      echo "  Warning: Could not extract a valid URL from line: '$line'. Skipping."
                      continue
                  fi
                  
                  process_rule "$original_name" "$url"
              done
          fi
          
          echo "--- Processing complete ---"
          
          # --- 生成最终配置文件 ---
          PROVIDER_CONFIG_PATH="$VERSIONED_OUTPUT_DIR/provider_config.yaml"
          echo "Generating final config file at $PROVIDER_CONFIG_PATH"

          {
            echo "---"
            echo "# Generated by GitHub Actions at $(date -u --rfc-3339=seconds)"
            echo "# This file uses YAML anchors for a compact configuration."
            echo ""
            echo "rule-anchor:"
            echo "  ip: &ip { type: http, interval: 86400, behavior: ipcidr }"
            echo "  domain: &domain { type: http, interval: 86400, behavior: domain }"
            echo "  classical: &classical { type: http, interval: 86400, behavior: classical }"
            echo ""
            echo "rule-providers:"
            cat "$PROVIDER_LINES_TMP"
            echo ""
            echo "# You can copy the following lines to your main config 'rules:' section."
            echo "# The policy (e.g., PROXY, DIRECT) should be replaced with your actual policy group name."
            echo "# rules:"
            cat "$RULESET_LINES_TMP"
          } > "$PROVIDER_CONFIG_PATH"

          rm -f "$PROVIDER_LINES_TMP" "$RULESET_LINES_TMP"

          # --- 生成汇总的 MD 文件 ---
          MRS_RULES_MD="mrs_rules.md"
          echo "# MRS Ruleset Links (Always Latest)" > "$MRS_RULES_MD"
          echo "" >> "$MRS_RULES_MD"
          echo "Generated at: $(date -u --rfc-3339=seconds)" >> "$MRS_RULES_MD"
          echo "" >> "$MRS_RULES_MD"
          echo '```yaml' >> "$MRS_RULES_MD"
          grep -E -- '- RULE-SET' "$PROVIDER_CONFIG_PATH" >> "$MRS_RULES_MD"
          echo '```' >> "$MRS_RULES_MD"

          # --- 创建 latest 目录并复制最新文件 ---
          LATEST_DIR="latest"
          rm -rf "$LATEST_DIR"
          mkdir -p "$LATEST_DIR"
          echo "Copying latest rules to /$LATEST_DIR directory..."
          # 检查 RULES_OUTPUT_DIR 中是否有文件，防止因 glob 匹配不到文件而报错
          if [ -n "$(ls -A $RULES_OUTPUT_DIR)" ]; then
              cp -r "$RULES_OUTPUT_DIR"/* "$LATEST_DIR/"
          else
              echo "No new rule files were generated, skipping copy to latest."
          fi
          cp "$PROVIDER_CONFIG_PATH" "$LATEST_DIR/provider_config.yaml"

          # --- 将最新的 provider_config.yaml 复制到根目录 ---
          echo "Copying latest provider_config.yaml to root directory..."
          cp "$LATEST_DIR/provider_config.yaml" ./provider_config.yaml

          # 设置 git commit 的 message
          echo "COMMIT_MSG=feat(rules): Auto update MRS rulesets to version $VERSION_TAG" >> $GITHUB_ENV
          # 创建新的 tag
          git tag "$VERSION_TAG"

      - name: Commit and Push to repository
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # 添加所有新生成的文件
          git add latest/ versioned_rules/ mrs_rules.md provider_config.yaml
          
          # 检查是否有文件变动
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            # 使用上一步的输出作为 commit message 的一部分
            git commit -m "${{ env.COMMIT_MSG }}"
            git push --follow-tags
          fi

