# Action 名称
name: Auto Convert Clash Rules to MRS

on:
  # 允许手动触发
  workflow_dispatch:

  # 定时任务：每周日北京时间早上6点运行 (UTC 时间 周六 22:00)
  schedule:
    - cron: '0 22 * * 6'
  
  # 当 rule_sources.txt 文件被推送到 main 分支时触发
  push:
    branches:
      - main
    paths:
      - 'rule_sources.txt'

jobs:
  build-ruleset:
    runs-on: ubuntu-latest
    # 授予 Action 写入仓库内容的权限
    permissions:
      contents: write
    steps:
      # 1. 检出你的仓库代码
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. 安装依赖 (jq 用于解析 JSON)
      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y jq

      # 3. 下载并设置 Mihomo
      - name: Setup Mihomo
        run: |
          # 从 GitHub API 获取最新的 Mihomo release URL，并筛选出唯一的 compatible 版本
          MIHOMO_LATEST_URL=$(curl -s "https://api.github.com/repos/MetaCubeX/mihomo/releases/latest" | jq -r '.assets[] | select(.name | contains("linux-amd64-compatible") and endswith(".gz")) | .browser_download_url' | head -n 1)
          
          if [ -z "$MIHOMO_LATEST_URL" ]; then
            echo "::error::无法找到 Mihomo 的 compatible 版本下载链接。"
            exit 1
          fi

          echo "Downloading Mihomo from $MIHOMO_LATEST_URL"
          # 下载、解压、赋予执行权限并移动到系统路径
          wget -qO mihomo.gz "$MIHOMO_LATEST_URL"
          gunzip mihomo.gz
          chmod +x mihomo
          sudo mv mihomo /usr/local/bin/
          # 验证安装成功
          echo "Mihomo version:"
          mihomo -v

      # 4. 运行转换脚本 (性能优化版)
      - name: Run Conversion Script
        id: conversion
        run: |
          # --- 1. 初始化目录和文件 ---
          MAIN_OUTPUT_DIR="versioned_rules"
          mkdir -p "$MAIN_OUTPUT_DIR"

          # 根据日期和现有文件夹数量，确定本次运行的唯一输出目录名
          TODAY=$(date -u +'%Y-%m-%d')
          RUN_OUTPUT_DIR_BASE="${MAIN_OUTPUT_DIR}/${TODAY}"
          RUN_OUTPUT_DIR="${RUN_OUTPUT_DIR_BASE}"
          COUNT=1
          while [ -d "$RUN_OUTPUT_DIR" ]; do
              RUN_OUTPUT_DIR="${RUN_OUTPUT_DIR_BASE}-${COUNT}"
              COUNT=$((COUNT + 1))
          done
          echo "本次运行的输出目录为: ${RUN_OUTPUT_DIR}"
          # 将目录名设置为 job 的输出，方便后续步骤使用
          echo "run_dir=${RUN_OUTPUT_DIR}" >> $GITHUB_OUTPUT

          # 定义本次运行的子目录和文件路径
          DOWNLOAD_DIR="downloads_tmp"
          RULES_SUBDIR="${RUN_OUTPUT_DIR}/rules"
          CONFIG_FILE="${RUN_OUTPUT_DIR}/provider_config.yaml"
          SUMMARY_FILE="mrs_rules.md" # 根目录的汇总文件，始终指向最新版本

          # 创建所需目录
          mkdir -p "$DOWNLOAD_DIR" "$RULES_SUBDIR"

          # 初始化配置文件和汇总文件
          echo "# Rule Providers for this version (${RUN_OUTPUT_DIR})" > "$CONFIG_FILE"
          echo "# Generated at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> "$CONFIG_FILE"
          echo "rule-providers:" >> "$CONFIG_FILE"

          rm -f "$SUMMARY_FILE"
          echo "# MRS 规则集列表 (最新)" > "$SUMMARY_FILE"
          echo "自动更新于: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> "$SUMMARY_FILE"
          echo "当前版本位于: \`[${RUN_OUTPUT_DIR}](./${RUN_OUTPUT_DIR})\`" >> "$SUMMARY_FILE"
          echo "" >> "$SUMMARY_FILE"

          # --- 2. 定义核心处理函数 ---

          # 全局变量，用于获取 GitHub Raw URL
          GITHUB_RAW_URL_BASE="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/${GITHUB_REF_NAME}"

          # 新增：转换和提交单个纯净规则文件的函数
          convert_and_commit_rule() {
              local display_name="$1"
              local source_file="$2"
              local rule_type="$3" # "domain" or "ipcidr"
              local original_sanitized_name="$4"

              # 为拆分后的文件创建唯一的文件名和 provider key
              local final_sanitized_name="${original_sanitized_name}_${rule_type}"
              local output_file_path="${RULES_SUBDIR}/${final_sanitized_name}.mrs"
              
              echo "  -> Converting ${source_file} as ${rule_type} to ${output_file_path}"
              
              if mihomo convert-ruleset "$rule_type" text "$source_file" "$output_file_path"; then
                  echo "     Success: 成功转换"
                  # 将拆分后的源文件也归档
                  mv "$source_file" "${RULES_SUBDIR}/${final_sanitized_name}.txt"

                  # A. 追加到 provider_config.yaml
                  echo "  # 原始名称: ${display_name}" >> "$CONFIG_FILE"
                  echo "  ${final_sanitized_name}:" >> "$CONFIG_FILE"
                  echo "    type: http" >> "$CONFIG_FILE"
                  echo "    behavior: ${rule_type}" >> "$CONFIG_FILE"
                  echo "    url: \"${GITHUB_RAW_URL_BASE}/${output_file_path}\"" >> "$CONFIG_FILE"
                  echo "    path: \"./rules/${final_sanitized_name}.mrs\"" >> "$CONFIG_FILE"
                  echo "    interval: 86400" >> "$CONFIG_FILE"
                  echo "" >> "$CONFIG_FILE"

                  # B. 追加到 mrs_rules.md
                  echo "- RULE-SET,${display_name},${GITHUB_RAW_URL_BASE}/${output_file_path}" >> "$SUMMARY_FILE"
              else
                  echo "::error::转换 ${source_file} 失败。"
              fi
          }

          process_rule() {
              local name="$1"
              local url="$2"
              
              url=$(echo "$url" | tr -d '\r' | xargs)
              if [[ ! "$url" =~ ^https?:// ]]; then
                  echo "Skipping non-URL rule: Name='${name}', Content='${url}'"
                  return
              fi

              echo "---"
              echo "Processing: Name='${name}', URL='${url}'"
              
              local sanitized_name
              sanitized_name=$(basename "$url" | sed 's/\.[^.]*$//' | sed 's/[^a-zA-Z0-9_.-]//g')
              if [[ -z "$sanitized_name" ]]; then sanitized_name="rule_$(date +%s%N)"; fi

              local extension="${url##*.}"
              local temp_input_file="${DOWNLOAD_DIR}/${sanitized_name}.${extension}"
              
              echo "Downloading to ${temp_input_file}..."
              if ! curl -L --retry 3 --retry-delay 5 --silent --show-error -o "$temp_input_file" "$url"; then
                  echo "::warning::下载 ${url} 失败，跳过。"
                  return
              fi
              
              if [ ! -s "$temp_input_file" ]; then
                  echo "::warning::下载的文件 ${temp_input_file} 为空，跳过。"
                  rm "$temp_input_file"
                  return
              fi

              if [[ "$extension" == "txt" || "$extension" == "list" ]]; then
                  echo "  File is a .txt/.list, using awk to split into domain/ipcidr/other for performance..."
                  local domain_temp_file="${DOWNLOAD_DIR}/${sanitized_name}.domains.txt"
                  local ipcidr_temp_file="${DOWNLOAD_DIR}/${sanitized_name}.ips.txt"
                  local other_temp_file="${DOWNLOAD_DIR}/${sanitized_name}.other.list"

                  # --- 性能优化：使用 awk 代替 shell 循环 ---
                  awk -v domain_f="$domain_temp_file" -v ip_f="$ipcidr_temp_file" -v other_f="$other_temp_file" '
                  {
                      # 保存原始行，用于 "other" 类别
                      original_line = $0
                      
                      # 移除注释和首尾空格
                      sub(/#.*/, "")
                      gsub(/^[ \t]+|[ \t]+$/, "")
                      
                      # 如果处理后为空行，则跳过
                      if ($0 == "") {
                          next
                      }
                      
                      # 匹配 domain 类型
                      if ($0 ~ /^(DOMAIN|DOMAIN-SUFFIX|DOMAIN-KEYWORD),/) {
                          sub(/^(DOMAIN|DOMAIN-SUFFIX|DOMAIN-KEYWORD),/, "")
                          print $0 >> domain_f
                          next
                      }
                      
                      # 匹配 ip-cidr 类型
                      if ($0 ~ /^IP-CIDR,/) {
                          sub(/^IP-CIDR,/, "")
                          # 处理 no-resolve 等情况
                          split($0, parts, ",")
                          print parts[1] >> ip_f
                          next
                      }
                      
                      # 其他所有不匹配的规则，写入 other 文件
                      print original_line >> other_f
                  }
                  ' "$temp_input_file"
                  
                  # 后续逻辑不变，检查拆分出的文件并处理
                  if [ -s "$domain_temp_file" ]; then
                      convert_and_commit_rule "${name} (Domain)" "$domain_temp_file" "domain" "$sanitized_name"
                  fi
                  if [ -s "$ipcidr_temp_file" ]; then
                      convert_and_commit_rule "${name} (IP)" "$ipcidr_temp_file" "ipcidr" "$sanitized_name"
                  fi
                  if [ -s "$other_temp_file" ]; then
                      local final_other_filename="${sanitized_name}_other.list"
                      local final_other_filepath="${RULES_SUBDIR}/${final_other_filename}"
                      echo "  -> Archiving unsupported rules to ${final_other_filepath}"
                      mv "$other_temp_file" "$final_other_filepath"

                      echo "  # 原始名称: ${name} (Unsupported)" >> "$CONFIG_FILE"
                      echo "  ${sanitized_name}_other:" >> "$CONFIG_FILE"
                      echo "    type: http" >> "$CONFIG_FILE"
                      echo "    behavior: classical" >> "$CONFIG_FILE"
                      echo "    url: \"${GITHUB_RAW_URL_BASE}/${final_other_filepath}\"" >> "$CONFIG_FILE"
                      echo "    path: \"./rules/${final_other_filename}\"" >> "$CONFIG_FILE"
                      echo "    interval: 86400" >> "$CONFIG_FILE"
                      echo "" >> "$CONFIG_FILE"

                      echo "- RULE-SET,${name} (Unsupported),${GITHUB_RAW_URL_BASE}/${final_other_filepath}" >> "$SUMMARY_FILE"
                  fi

                  rm "$temp_input_file"

              elif [[ "$extension" == "yaml" || "$extension" == "yml" ]]; then
                  echo "  File is a .yaml, converting as pure domain..."
                  mv "$temp_input_file" "${DOWNLOAD_DIR}/${sanitized_name}.domains.txt"
                  convert_and_commit_rule "$name" "${DOWNLOAD_DIR}/${sanitized_name}.domains.txt" "domain" "$sanitized_name"
              else
                  echo "::warning::不支持的文件扩展名 '${extension}' 来自 ${url}，跳过。"
                  rm "$temp_input_file"
              fi
          }

          # --- 3. 主逻辑 ---
          if [[ -f "rule_sources.txt" && -s "rule_sources.txt" ]]; then
              echo "检测到 rule_sources.txt，开始处理自定义链接。"
              while IFS= read -r url || [[ -n "$url" ]]; do
                  if [[ -z "$url" || "$url" =~ ^# ]]; then continue; fi
                  name=$(basename "$url" | sed 's/\.[^.]*$//')
                  process_rule "$name" "$url"
              done < "rule_sources.txt"
          else
              echo "rule_sources.txt 不存在或为空，使用默认的 .ini 文件。"
              DEFAULT_INI_URL="https://raw.githubusercontent.com/cutethotw/ClashRule/main/GeneralClashRule.ini"
              INI_FILE="${DOWNLOAD_DIR}/GeneralClashRule.ini"
              
              if ! curl -L --retry 3 -o "$INI_FILE" "$DEFAULT_INI_URL"; then
                  echo "::error::无法下载默认的 INI 配置文件，任务中止。"
                  exit 1
              fi
              
              grep -E '^\s*;?ruleset=' "$INI_FILE" | sed -E 's/^\s*;?ruleset=//' | sed 's/,clash-classic:/,/' | while IFS=, read -r name url; do
                  process_rule "$name" "$url"
              done
          fi

          echo "--- 处理完成 ---"
          echo "查看本次生成的配置文件: ${CONFIG_FILE}"
          echo "查看最新的汇总文件: ${SUMMARY_FILE}"

          rm -rf "$DOWNLOAD_DIR" # 清理临时下载目录

      # 5. 提交并推送生成的 .mrs 文件和汇总文件到仓库
      - name: Commit and Push changes
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          git add versioned_rules/ mrs_rules.md
          
          if git diff --staged --quiet; then
            echo "没有文件变动，无需提交。"
          else
            git commit -m "feat(rules): Auto update MRS rulesets to version ${{ steps.conversion.outputs.run_dir }}"
            git push
          fi

