name: Auto Convert Clash Rules to MRS

on:
  push:
    branches:
      - main
  workflow_dispatch: # å…è®¸æ‰‹åŠ¨è§¦å‘
  schedule:
    - cron: '0 0 * * 0' # æ¯å‘¨æ—¥ UTC æ—¶é—´ 00:00 è¿è¡Œ

jobs:
  convert-rules:
    runs-on: ubuntu-latest
    permissions:
      contents: write # æˆäºˆ action ä¿®æ”¹ä»“åº“å†…å®¹çš„æƒé™

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all tags, so we can count previous runs on the same day.

      - name: Install dependencies (jq, curl, wget)
        run: sudo apt-get update && sudo apt-get install -y jq curl wget

      - name: Install Mihomo
        run: |
          # å¢åŠ ç‰ˆæœ¬é€‰æ‹©çš„å¥å£®æ€§ï¼Œä¼˜å…ˆé€‰æ‹© compatible ç‰ˆæœ¬
          MIHOMO_LATEST_URL=$(curl -s "https://api.github.com/repos/MetaCubeX/mihomo/releases/latest" | jq -r '.assets[] | select(.name | contains("linux-amd64-compatible")) | .browser_download_url')
          
          # å¦‚æœæ²¡æœ‰ compatible ç‰ˆæœ¬ï¼Œåˆ™é€‰æ‹©ä¸€ä¸ªé€šç”¨çš„ç‰ˆæœ¬ä½œä¸ºå¤‡ç”¨
          if [ -z "$MIHOMO_LATEST_URL" ]; then
            MIHOMO_LATEST_URL=$(curl -s "https://api.github.com/repos/MetaCubeX/mihomo/releases/latest" | jq -r '[.assets[] | select(.name | contains("linux-amd64") and endswith(".gz"))] | .[0].browser_download_url')
          fi

          echo "Downloading Mihomo from $MIHOMO_LATEST_URL"
          
          # ä¸‹è½½ã€è§£å‹ã€èµ‹äºˆæ‰§è¡Œæƒé™å¹¶ç§»åŠ¨åˆ°ç³»ç»Ÿè·¯å¾„
          wget -qO mihomo.gz "$MIHOMO_LATEST_URL"
          gunzip mihomo.gz
          chmod +x mihomo
          sudo mv mihomo /usr/local/bin/
          
          # éªŒè¯å®‰è£…æˆåŠŸ
          echo "Mihomo version:"
          mihomo -v

      - name: Process and Convert Rules
        id: process_rules
        run: |
          set -e # å¦‚æœä»»ä½•å‘½ä»¤å¤±è´¥ï¼Œåˆ™ç«‹å³é€€å‡º

          # --- å…¨å±€å˜é‡å’Œåˆå§‹åŒ– ---
          # åˆ›å»ºä¸´æ—¶ç›®å½•
          DOWNLOADS_DIR="downloads_tmp"
          mkdir -p "$DOWNLOADS_DIR"

          # åˆ›å»ºç‰ˆæœ¬åŒ–è¾“å‡ºç›®å½•
          DATE_SUFFIX=$(date -u +"%Y-%m-%d")
          RUN_COUNT=$(git tag -l "${DATE_SUFFIX}-*" | wc -l)
          VERSION_TAG="${DATE_SUFFIX}-${RUN_COUNT}"
          VERSIONED_OUTPUT_DIR="versioned_rules/$VERSION_TAG"
          RULES_OUTPUT_DIR="$VERSIONED_OUTPUT_DIR/rules"
          mkdir -p "$RULES_OUTPUT_DIR"
          
          # ä¸´æ—¶æ–‡ä»¶ï¼Œç”¨äºå­˜å‚¨æœ€ç»ˆé…ç½®æ–‡ä»¶çš„å„ä¸ªéƒ¨åˆ†
          PROVIDER_LINES_TMP="provider_lines.tmp"
          RULESET_LINES_TMP="ruleset_lines.tmp"
          PROXY_GROUPS_TMP="proxy_groups.tmp" # ç”¨äºæš‚å­˜è§£æå‡ºçš„ç­–ç•¥ç»„
          > "$PROVIDER_LINES_TMP"
          > "$RULESET_LINES_TMP"
          > "$PROXY_GROUPS_TMP"

          # è¿è¡Œæ‘˜è¦è®¡æ•°å™¨
          declare -i total_processed=0
          declare -i total_succeeded=0
          declare -i total_failed=0
          declare -i total_skipped=0

          # --- å‡½æ•°å®šä¹‰ ---

          # å‡½æ•°ï¼šè½¬æ¢è§„åˆ™å¹¶è®°å½•ç»“æœ
          convert_and_commit_rule() {
              local type="$1"
              local format="$2"
              local input_file="$3"
              local base_name="$4"
              local output_dir="$5"
              local original_name_with_emoji="$6"

              local provider_name="$base_name"
              local final_raw_file="$output_dir/${base_name}.txt"
              local url_path="main/latest/${base_name}"
              local success=false

              if [[ "$type" == "classical" ]]; then
                  local output_file="$output_dir/${base_name}.list"
                  url_path+=".list"
                  cp "$input_file" "$output_file"
                  echo "  Archived unsupported rules to ${output_file}"
                  success=true
              else
                  local output_file="$output_dir/${base_name}.mrs"
                  url_path+=".mrs"
                  local input_for_mihomo="$input_file"
                  local temp_clean_input="cleaned_for_mrs.tmp"

                  if [[ "$format" == "text" ]]; then
                      # ä½¿ç”¨æ›´å¥å£®çš„ awk å‘½ä»¤ï¼Œæ­£ç¡®å¤„ç†å¸¦åç¼€çš„ IP-CIDR å’Œå„ç±» DOMAIN è§„åˆ™
                      awk -F, '
                          !/^#/ && !/^[ \t\r\n]*$/ {
                              if (NF > 1) { print $2; } else { print $0; }
                          }
                      ' "$input_file" > "$temp_clean_input"
                      input_for_mihomo="$temp_clean_input"
                  fi

                  echo "  Converting: Type=${type}, Format=${format}"
                  if mihomo convert-ruleset "$type" "$format" "$input_for_mihomo" "$output_file"; then
                      echo "  Successfully ran mihomo conversion."
                      success=true
                  else
                      echo "  Error: Mihomo command failed for ${input_file}."
                  fi
                  if [[ "$format" == "text" ]]; then rm -f "$temp_clean_input"; fi
              fi

              if [[ "$success" == true && -s "$output_file" ]]; then
                  total_succeeded+=1
                  cp "$input_file" "$final_raw_file"
                  local anchor_name="$type" # å…³é”®ä¿®æ­£ï¼šç¡®ä¿é”šç‚¹åç§°ä¸è¡Œä¸ºä¸€è‡´
                  if [[ "$type" == "ipcidr" ]]; then anchor_name="ip"; fi # å…¼å®¹ä½ åŸæœ‰çš„ &ip é”šç‚¹å‘½å
                  local full_url="https://raw.githubusercontent.com/${{ github.repository }}/${url_path}"
                  echo "  ${provider_name}: { <<: *${anchor_name}, url: '${full_url}' }" >> "$PROVIDER_LINES_TMP"
                  echo "- RULE-SET,${provider_name},${original_name_with_emoji}" >> "$RULESET_LINES_TMP"
              elif [[ "$success" == true ]]; then
                  total_failed+=1
                  echo "  Warning: Generated file is empty, conversion likely failed silently. Skipping."
              else
                  total_failed+=1
              fi
          }

          # ã€å·²æ›´æ–°ã€‘å‡½æ•°ï¼šæ‹†åˆ† .list/.txt æˆ–å·²è§£æçš„ .yaml æ–‡ä»¶å¹¶è½¬æ¢
          split_and_convert() {
              local input_file="$1"
              local base_name="$2"
              local output_dir="$3"
              local original_name_with_emoji="$4"
              local file_type="$5" # "yaml" or "text"

              echo "  Splitting ${file_type} file into domain/ipcidr/other..."
              
              local domain_file="${base_name}_domain.txt"
              local ipcidr_file="${base_name}_ipcidr.txt"
              local other_file="${base_name}_other.list"
              > "$domain_file"; > "$ipcidr_file"; > "$other_file"
              
              local awk_script='
                  function strip(s) {
                      sub(/^[ \t\r\n]+/, "", s);
                      sub(/[ \t\r\n]+$/, "", s);
                      return s;
                  }
                  # ä¸»é€»è¾‘
                  {
                      line = strip($0);
                      if (index(line, ",")) {
                          prefix = toupper(substr(line, 1, index(line, ",") - 1));
                          prefix = strip(prefix);
                          if (prefix == "DOMAIN" || prefix == "DOMAIN-SUFFIX" || prefix == "DOMAIN-KEYWORD") {
                              print line >> "'"$domain_file"'";
                          } else if (prefix == "IP-CIDR" || prefix == "IP-CIDR6") {
                              print line >> "'"$ipcidr_file"'";
                          } else {
                              print line >> "'"$other_file"'";
                          }
                      } else {
                          # ä¸å¸¦é€—å·çš„è¡Œé»˜è®¤ä¸ºåŸŸå
                          print line >> "'"$domain_file"'";
                      }
                  }
              '
              
              if [[ "$file_type" == "yaml" ]]; then
                  # ä» payload: å¼€å§‹è§£æï¼Œå¹¶ç§»é™¤ yaml çš„ list æ ¼å¼
                  sed -n '/payload:/,$p' "$input_file" | sed -e '1d' -e "s/^[ \t-]*'//;s/'$//" -e 's/^[ \t-]*"//;s/"$//' -e 's/^[ \t-]*//' | awk "$awk_script"
              else # text
                  awk '!/^#/ && !/^[ \t\r\n]*$/' "$input_file" | awk "$awk_script"
              fi

              if [ -s "$domain_file" ]; then
                  convert_and_commit_rule "domain" "text" "$domain_file" "${base_name}_domain" "$output_dir" "${original_name_with_emoji}"
              fi
              if [ -s "$ipcidr_file" ]; then
                  convert_and_commit_rule "ipcidr" "text" "$ipcidr_file" "${base_name}_ipcidr" "$output_dir" "${original_name_with_emoji}"
              fi
              if [ -s "$other_file" ]; then
                  convert_and_commit_rule "classical" "text" "$other_file" "${base_name}_other" "$output_dir" "${original_name_with_emoji}"
              fi
              
              rm -f "$domain_file" "$ipcidr_file" "$other_file"
          }

          # å‡½æ•°ï¼šå¤„ç†å•ä¸ªè§„åˆ™
          process_rule() {
              local original_name="$1"
              local url="$2"
              total_processed+=1
              
              echo "---"
              echo "Processing: Name='${original_name}', URL='${url}'"

              if ! [[ "$url" =~ ^https?:// ]]; then
                  total_skipped+=1
                  echo "  Warning: Invalid URL format (e.g., GEOIP, FINAL), skipping."
                  return
              fi

              local sanitized_filename_base=$(basename "$url" | sed 's/\.[^.]*$//' | sed 's/[^a-zA-Z0-9_.-]//g')
              local extension="${url##*.}"
              local downloaded_file="$DOWNLOADS_DIR/${sanitized_filename_base}.${extension}"

              echo "  Downloading to ${downloaded_file}..."
              if ! curl -L --retry 3 --fail -s -o "$downloaded_file" "$url"; then
                  total_failed+=1
                  echo "  Warning: Download failed for ${url} after 3 retries, skipping."
                  return
              fi

              if [ ! -s "$downloaded_file" ]; then
                  total_skipped+=1
                  echo "  Warning: Downloaded file is empty, skipping processing."
                  return
              fi

              # ã€å·²æ›´æ–°ã€‘å¯¹æ‰€æœ‰æ–‡ä»¶ç±»å‹éƒ½ä½¿ç”¨æ‹†åˆ†é€»è¾‘
              if [[ "$extension" == "yaml" ]]; then
                  split_and_convert "$downloaded_file" "$sanitized_filename_base" "$RULES_OUTPUT_DIR" "$original_name" "yaml"
              elif [[ "$extension" == "txt" || "$extension" == "list" ]]; then
                  split_and_convert "$downloaded_file" "$sanitized_filename_base" "$RULES_OUTPUT_DIR" "$original_name" "text"
              else
                  total_skipped+=1
                  echo "  Warning: Unsupported file extension '.${extension}', skipping."
              fi
          }

          # --- ä¸»é€»è¾‘ ---
          
          # å¦‚æœ rule_sources.txt å­˜åœ¨ï¼Œåˆ™å¤„ç†å®ƒ
          if [ -s "rule_sources.txt" ]; then
              echo "Custom 'rule_sources.txt' found, processing it."
              while IFS= read -r line; do
                  line=$(echo "$line" | tr -d '\r' | xargs)
                  if [ -z "$line" ]; then continue; fi
                  
                  # æ™ºèƒ½è§£æï¼šåŒæ—¶æ”¯æŒ ini æ ¼å¼å’Œçº¯ URL æ ¼å¼
                  if [[ "$line" == *"ruleset="* ]]; then
                      line_content=$(echo "$line" | sed -e 's/^\s*ruleset=//' -e 's/clash-classic://')
                      url=$(echo "$line_content" | sed -e 's/.*,//' -e 's/^[ \t]*//' -e 's/[ \t]*$//')
                      original_name=$(echo "$line_content" | sed -e 's/,.*//' -e 's/^[ \t]*//' -e 's/[ \t]*$//')
                  else
                      url="$line"
                      name=$(basename "$url" | sed 's/\.[^.]*$//')
                      original_name="$name"
                  fi

                  if [ -n "$url" ]; then
                      process_rule "$original_name" "$url"
                  fi
              done < rule_sources.txt
          fi
          
          # ç°åœ¨æ€»æ˜¯å¤„ç†é»˜è®¤çš„ .ini æ–‡ä»¶
          echo "Processing default .ini file."
          INI_URL="https://raw.githubusercontent.com/webshell8808/clash/refs/heads/main/Custom_Clash.ini"
          INI_FILE="$DOWNLOADS_DIR/GeneralClashRule.ini"
          if ! curl -L --fail -s -o "$INI_FILE" "$INI_URL"; then
              echo "WARNING: Could not download the main .ini file. Skipping."
          else
              # è§£æç­–ç•¥ç»„ (custom_proxy_group) ä»¥ä¾›ç”Ÿæˆå®Œæ•´é…ç½®
              grep "custom_proxy_group=" "$INI_FILE" | while read -r gline; do
                  g_content=$(echo "$gline" | sed 's/custom_proxy_group=//' | tr -d '\r')
                  g_name=$(echo "$g_content" | cut -d'`' -f1)
                  g_type=$(echo "$g_content" | cut -d'`' -f2)
                  g_params=$(echo "$g_content" | cut -d'`' -f3-)
                  {
                    echo "  - name: \"$g_name\""
                    echo "    type: $g_type"
                    if [[ "$g_type" == "url-test" || "$g_type" == "fallback" ]]; then
                      echo "    url: \"$(echo "$g_params" | cut -d'`' -f2)\""
                      echo "    interval: 300"
                    else
                      echo "    proxies:"
                      IFS='`' read -ra ADDR <<< "$g_params"
                      for i in "${ADDR[@]}"; do clean_p=$(echo "$i" | sed 's/\[\]//g'); [ -n "$clean_p" ] && echo "      - \"$clean_p\""; done
                    fi
                  } >> "$PROXY_GROUPS_TMP"
              done

              # ä½¿ç”¨è¿›ç¨‹æ›¿æ¢ <(...) æ¥é¿å…å­shellé—®é¢˜
              while IFS= read -r line; do
                  line_content=$(echo "$line" | tr -d '\r' | sed -e 's/^\s*ruleset=//' -e 's/clash-classic://')
                  url=$(echo "$line_content" | sed -e 's/.*,//' -e 's/^[ \t]*//' -e 's/[ \t]*$//')
                  original_name=$(echo "$line_content" | sed -e 's/,.*//' -e 's/^[ \t]*//' -e 's/[ \t]*$//')

                  if [ -z "$url" ]; then
                      echo "  Warning: Could not extract a valid URL from line: '$line'. Skipping."
                      continue
                  fi
                  
                  if [[ "$url" == "[]FINAL" ]]; then
                      echo "- MATCH,$original_name" >> "$RULESET_LINES_TMP"
                  else
                      process_rule "$original_name" "$url"
                  fi
              done < <(grep -E '^\s*ruleset=' "$INI_FILE" || true)
          fi
          
          echo "--- Processing complete ---"
          
          # --- ç”Ÿæˆæœ€ç»ˆé…ç½®æ–‡ä»¶ ---
          # å®šä¹‰ä¸€ä¸ªé€šç”¨çš„ç”Ÿæˆå‡½æ•°ï¼Œä¿æŒè¾“å‡ºæ ¼å¼å®¡ç¾ä¸€è‡´
          generate_config() {
              local mode="$1"
              local output_path="$2"
              {
                echo "---"
                echo "# Generated by GitHub Actions at $(date -u --rfc-3339=seconds)"
                echo "# Mode: $mode"
                echo ""
                echo "mixed-port: 7890"
                echo "allow-lan: true"
                echo "log-level: info"
                if [ "$mode" == "fake-ip" ]; then
                  echo "dns: { enable: true, ipv6: false, enhanced-mode: fake-ip, nameserver: [223.5.5.5, 119.29.29.29], fallback: [8.8.8.8, 1.1.1.1], fake-ip-range: 198.18.0.1/16 }"
                elif [ "$mode" == "redir-host" ]; then
                  echo "dns: { enable: true, ipv6: false, enhanced-mode: redir-host, nameserver: [223.5.5.5, 119.29.29.29], fallback: [8.8.8.8, 1.1.1.1] }"
                fi
                echo ""
                echo "proxy-groups:"
                cat "$PROXY_GROUPS_TMP"
                echo ""
                echo "rule-anchor:"
                echo "  ip: &ip { type: http, interval: 86400, behavior: ipcidr }"
                echo "  domain: &domain { type: http, interval: 86400, behavior: domain }"
                echo "  classical: &classical { type: http, interval: 86400, behavior: classical }"
                echo ""
                echo "rule-providers:"
                cat "$PROVIDER_LINES_TMP"
                echo ""
                echo "rules:"
                cat "$RULESET_LINES_TMP"
                echo "- GEOIP,CN,ğŸ¯ å›½å†…æµé‡"
                echo "- MATCH,ğŸš€ å›½å¤–æµé‡"
              } > "$output_path"
          }

          # ç”Ÿæˆä¸‰ç§æ¨¡å¼çš„é…ç½®
          generate_config "fake-ip" "$VERSIONED_OUTPUT_DIR/provider_config_fakeip.yaml"
          generate_config "redir-host" "$VERSIONED_OUTPUT_DIR/provider_config_redirhost.yaml"
          generate_config "standard" "$VERSIONED_OUTPUT_DIR/provider_config.yaml"

          rm -f "$PROVIDER_LINES_TMP" "$RULESET_LINES_TMP" "$PROXY_GROUPS_TMP"

          # --- ç”Ÿæˆæ±‡æ€»çš„ MD æ–‡ä»¶ ---
          MRS_RULES_MD="mrs_rules.md"
          echo "# MRS Ruleset Links (Always Latest)" > "$MRS_RULES_MD"; echo "" >> "$MRS_RULES_MD"
          echo "Generated at: $(date -u --rfc-3339=seconds)" >> "$MRS_RULES_MD"; echo "" >> "$MRS_RULES_MD"
          echo '```yaml' >> "$MRS_RULES_MD"
          grep -E -- '- RULE-SET' "$VERSIONED_OUTPUT_DIR/provider_config.yaml" >> "$MRS_RULES_MD" || true
          echo '```' >> "$MRS_RULES_MD"

          # --- åˆ›å»º latest ç›®å½•å¹¶å¤åˆ¶æœ€æ–°æ–‡ä»¶ ---
          LATEST_DIR="latest"
          echo "Ensuring a clean 'latest' directory by removing and recreating it..."
          rm -rf "$LATEST_DIR"
          mkdir -p "$LATEST_DIR"

          echo "Copying latest rules to /$LATEST_DIR directory..."
          if [ -n "$(ls -A $RULES_OUTPUT_DIR 2>/dev/null)" ]; then
              # ã€å·²æ›´æ–°ã€‘ä½¿ç”¨ -f (force) æ ‡å¿—ä½œä¸ºåŒé‡ä¿é™©ï¼Œç¡®ä¿å¼ºåˆ¶è¦†ç›–
              cp -rf "$RULES_OUTPUT_DIR"/* "$LATEST_DIR/"
          else
              echo "No new rule files were generated, skipping copy to latest."
          fi
          # ã€å·²æ›´æ–°ã€‘å¤åˆ¶æ‰€æœ‰ç”Ÿæˆçš„é…ç½®æ–‡ä»¶
          cp -f "$VERSIONED_OUTPUT_DIR"/provider_config*.yaml "$LATEST_DIR/"

          # --- å°†é»˜è®¤çš„ provider_config.yaml å¤åˆ¶åˆ°æ ¹ç›®å½• ---
          echo "Copying latest provider_config.yaml to root directory..."
          cp -f "$VERSIONED_OUTPUT_DIR/provider_config.yaml" ./provider_config.yaml

          # ã€å·²æ›´æ–°ã€‘å°†ç‰ˆæœ¬æ ‡ç­¾å¯¼å‡ºåˆ° GITHUB_ENV ä¾›ä¸‹ä¸€æ­¥ä½¿ç”¨
          echo "COMMIT_MSG=feat(rules): Auto update MRS rulesets to version $VERSION_TAG" >> $GITHUB_ENV
          echo "VERSION_TAG=${VERSION_TAG}" >> $GITHUB_ENV
          git tag "$VERSION_TAG"

          # --- æ‰“å°è¿è¡Œæ‘˜è¦ ---
          echo "--- Run Summary ---"
          echo "Rules Processed: $total_processed"
          echo "Rules Succeeded: $total_succeeded"
          echo "Rules Skipped (Invalid/Empty): $total_skipped"
          echo "Rules Failed (Download/Convert): $total_failed"

      - name: Commit and Push to repository
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          git add latest/ versioned_rules/ mrs_rules.md provider_config.yaml
          
          # ã€å·²æ›´æ–°ã€‘æ€»æ˜¯æ¨é€æ ‡ç­¾ï¼Œä»¥ç¡®ä¿å³ä½¿æ²¡æœ‰æ–‡ä»¶æ›´æ”¹ï¼Œè¿è¡Œè®¡æ•°ä¹Ÿèƒ½æ­£ç¡®å¢åŠ 
          echo "Pushing tag ${{ env.VERSION_TAG }} to ensure run count is updated..."
          git push origin "refs/tags/${{ env.VERSION_TAG }}"
          
          if git diff --staged --quiet; then
            echo "No file changes to commit."
          else
            git commit -m "${{ env.COMMIT_MSG }}"
            git push
          fi
